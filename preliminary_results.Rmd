---
title: "Analysis of the relationships history of women 40+"
author: 
  - Adriana Clavijo Daza 
institute:
  - Statistics and Data Science Master's, Universität Bern
date: "2022-06-02"
output: beamer_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

```{r libs, echo = FALSE}
library(readxl)
library(tidyr)
library(dplyr)
library(stringr)
library(ggplot2)
library(TraMineR)
library(cluster)
source("predict_scores.R")
source("get_MSE.R")
```

```{r data, echo = FALSE, cache=TRUE}
cs_levels <- 1:6
cs_labels <- c("Single", "Married", "Registered partnership", 
               "Same-sex partnership", "Divorced", "Widowed")

rs_levels <- 1:4
rs_labels <- c("No relationship", "Relationship", 
               "Open relationship", "Changing relationships")

liv_levels <- 0:2
liv_labels <- c("No partner", "Yes", "No")

file <- "../Data_original/Tracker_Uni-Zurich_Modified.xlsx"

raw_data <- read_excel(file)

raw_data <- raw_data %>% 
  select_if(~!all(is.na(.)))

new_names <- vector(mode = "character")

for (i in 1:12){
  new_names[2*(i-1)+1] <- paste0("Start-", i)
  new_names[2*(i-1)+2] <- paste0("End-", i)
}

colnames(raw_data)[1] <- "Id"
colnames(raw_data)[58] <- "Age"
colnames(raw_data)[59:82] <- new_names
colnames(raw_data)[83:94] <- paste0("Civil-", 1:12)
colnames(raw_data)[95:106] <- paste0("Relationship-", 1:12)
colnames(raw_data)[119:130] <- paste0("Children-", 1:12)
colnames(raw_data)[131:142] <- paste0("Living-", 1:12)

raw_data <- raw_data %>% 
  select(c(1, 58:106, 119:142)) 

raw_data <- raw_data %>% 
  pivot_longer(cols = starts_with("Start"),
               names_to = "Phase",
               names_prefix = "Start-",
               values_to = "Start_age",
               values_drop_na = TRUE) %>% 
  pivot_longer(cols = starts_with("End"),
               names_to = "Match2",
               names_prefix = "End-",
               values_to = "End_age",
               values_drop_na = TRUE) %>% 
  pivot_longer(cols = starts_with("Civil"),
               names_to = "Match3",
               names_prefix = "Civil-",
               values_to = "Civil_status",
               values_drop_na = TRUE) %>% 
  pivot_longer(cols = starts_with("Relationship"),
               names_to = "Match4",
               names_prefix = "Relationship-",
               values_to = "Relationship_status",
               values_drop_na = TRUE) %>% 
  pivot_longer(cols = starts_with("Children"),
               names_to = "Match5",
               names_prefix = "Children-",
               values_to = "Children",
               values_drop_na = TRUE) %>% 
  pivot_longer(cols = starts_with("Living"),
               names_to = "Match6",
               names_prefix = "Living-",
               values_to = "Living_situation",
               values_drop_na = TRUE) %>% 
  filter(Phase == Match2,
         Phase == Match3,
         Phase == Match4,
         Phase == Match5,
         Phase == Match6,
         Start_age >= 15,
         !Id %in% c("zr34u", "EN61O", "DN15U"),
         !(Id == "GB28U" & Phase == "4")) %>% 
  select(-contains("Match")) %>% 
  mutate(Civil_status = factor(Civil_status, levels = cs_levels, labels = cs_labels),
         Relationship_status = factor(Relationship_status, levels = rs_levels, labels = rs_labels),
         Phase = as.numeric(Phase),
         Living_situation = factor(Living_situation, levels = liv_levels, labels = liv_labels),
         Children = case_when(
           Children == 0 ~ "No",
           is.na(Children) ~ "No",
           Children > 0 ~ "Yes"
         )
         )

tst <- raw_data %>% 
  mutate(
    Status= case_when(
      Relationship_status == "No relationship" & Civil_status == "Single" & Children == "No" ~ 1,
      Relationship_status == "No relationship" & Civil_status == "Single" & Children == "Yes" ~ 2,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Single" & Children == "No" & Living_situation == "No" ~ 5,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Single" & Children == "No" & Living_situation == "Yes"  ~ 6,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Single" & Children == "Yes" & Living_situation == "No" ~ 7,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Single" & Children == "Yes"  & Living_situation == "Yes" ~ 8,
      Relationship_status == "Changing relationships" & Civil_status == "Single" & Children == "No" ~ 3,
      Relationship_status == "Changing relationships" & Civil_status == "Single" & Children == "Yes" ~ 4,
      Civil_status %in% c("Married", "Registered partnership") & Children == "No" ~ 9,
      Civil_status %in% c("Married", "Registered partnership") & Children == "Yes" ~ 10,
      Relationship_status == "No relationship" & Civil_status == "Divorced" & Children == "No" ~ 1,
      Relationship_status == "No relationship" & Civil_status == "Divorced" & Children == "Yes" ~ 5,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Divorced" & Children == "No" & Living_situation == "No" ~ 5,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Divorced" & Children == "No" & Living_situation == "Yes" ~ 6,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Divorced" & Children == "Yes" & Living_situation == "No" ~ 7,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Divorced" & Children == "Yes" & Living_situation == "Yes" ~ 8,
      Relationship_status == "Changing relationships" & Civil_status == "Divorced" & Children == "No" ~ 3,
      Relationship_status == "Changing relationships" & Civil_status == "Divorced" & Children == "Yes" ~ 4,
      Relationship_status == "No relationship" & Civil_status == "Widowed" & Children == "No" ~ 1,
      Relationship_status == "No relationship" & Civil_status == "Widowed" & Children == "Yes" ~ 2,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Widowed" & Children == "No" & Living_situation == "No" ~ 5,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Widowed" & Children == "No" & Living_situation == "Yes" ~ 6,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Widowed" & Children == "Yes" & Living_situation == "No" ~ 7,
      Relationship_status %in% c("Relationship", "Open relationship") & Civil_status == "Widowed" & Children == "Yes" & Living_situation == "Yes" ~ 8,
      Relationship_status == "Changing relationships" & Civil_status == "Widowed" & Children == "No" ~ 3,
      Relationship_status == "Changing relationships" & Civil_status == "Widowed" & Children == "Yes" ~ 4,
      TRUE ~ 0
      )
    )                

status_levels <- 1:10
status_labels <- c("Single+no ch.",
                   "Single+ch.",
                   "Changing rel.+no ch.",
                   "Changing rel.+ch.",
                   "Rel.+apart+no ch.",
                   "Rel.+together+no ch.",
                   "Rel.+apart+ch.",
                   "Rel.+together+ch.",
                   "Married+no ch.",
                   "Married+ch.")

rh_data <- tst %>% 
  select(-Civil_status, -Relationship_status, -Children) %>% 
  mutate(Status_char = factor(Status, levels = status_levels, labels = status_labels))
```


## Motivation

```{r, out.width = "150px", fig.align = "center"}
knitr::include_graphics("../Output/couple.png")
```

Understand the differences in the romantic relationships history of a group of women.


## Women 40+ Healthy Aging Study (i)

```{r, echo = FALSE, out.width= "49%", out.height = "20%", fig.show = "hold", fig.align = "center"}
knitr::include_graphics(c("../Output/logo2.png", "../Output/logo1.png"))
``` 

- Data from 250 individuals collected between June 2017 and February 2018.
- Psychometric instrument to obtain information about the history of romantic relationships of women aged between 40 and 75 years.


## Women 40+ Healthy Aging Study (ii)

- Information about relationship phases starting from the age of 15 years until the current age at the time of the data collection.
- The phases are defined by the start and end age and for each phase and information about civil status, relationship status, living situation, children and quality of the relationship was collected.
- The data of the phases is then used to build a yearly sequence.


## Data example

Consider the relationship status:

```{r, out.width = "300px"}
knitr::include_graphics("../Output/sequence_example1.png")
```
*Current age

- No relationship (NR)
- In a relationship (R)
- Open relationship (OR)
- Changing relationships (CR)


## What is personality?

```{r, out.width = "200px", fig.align = "center"}
knitr::include_graphics("../Output/personality1.png")
```

Personality refers to the enduring characteristics and behavior that comprise a person’s unique adjustment to life, including major traits, interests, drives, values, self-concept, abilities, and emotional patterns.


## The "Big Five" personality traits

```{r, out.width = "300px", fig.align = "center"}
knitr::include_graphics("../Output/personality2.png")
```


## Research question

- Can we get a good prediction of personality scores based on the relationship history sequences?


## Data pre-processing

- Manual corrections of several inconsistent and incomplete records.
- Several additional automatic checks to identify sequences with inconsistent data.
- Corrections based on secondary data source.
- Identification and selection of the variables and patterns that provide a wider perspective of the individuals' situations.
- In total, 239 individuals are considered for the analysis.


## Frequency of phases - Civil status

```{r civil-status, out.width = "280px", fig.align = "center"}
plot1 <- ggplot(data = raw_data, aes(Civil_status))
plot1 + geom_bar() + geom_text(stat = "count", aes(label = ..count..), vjust=-0.25) + labs(x = "Civil status") + theme(axis.text = element_text(size = 14)) 
```


## Frequency of phases - Relationship status

```{r relationship-status, out.width = "280px", fig.align = "center"}
plot2 <- ggplot(data = raw_data, aes(Relationship_status))
plot2 + geom_bar() + geom_text(stat = "count", aes(label = ..count..), vjust=-0.25) + labs(x = "Relationship status") + theme(axis.text = element_text(size = 14))
```


## Frequency of phases - Civil & relationship status

```{r both, out.width = "280px", fig.align = "center"}
ggplot(raw_data, aes(x = Civil_status))+
  geom_bar(
    aes(fill = Relationship_status), stat = "count", color = "white",
    position = position_dodge(0.9)
  ) + labs(x = "Civil & relationship status") + theme(axis.text = element_text(size = 14))
```


## Frequency of phases - Relationship status & living situation

```{r living-situation, out.width = "250px", fig.align = "center"}
ggplot(raw_data, aes(x = Relationship_status))+
  geom_bar(
    aes(fill = Living_situation), stat = "count", color = "white",
    position = position_dodge(0.9)
  ) + labs(x = "Relationship status & living situation") + theme(axis.text = element_text(size = 14))
# plot4 <- ggplot(data = raw_data, aes(Living_situation))
# plot4 + geom_bar() + geom_text(stat = "count", aes(label = ..count..), vjust=-0.25) + labs(x = "Living situation") + theme(axis.text = element_text(size = 14))
```


## Frequency of phases - Civil status & (having) children

```{r children, out.width = "250px", fig.align = "center"}
ggplot(raw_data, aes(x = Relationship_status))+
  geom_bar(
    aes(fill = Children), stat = "count", color = "white",
    position = position_dodge(0.9)
  ) + labs(x = "Civil status & (having) children") + theme(axis.text = element_text(size = 14))
# plot3 <- ggplot(data = raw_data, aes(Children))
# plot3 + geom_bar() + geom_text(stat = "count", aes(label = ..count..), vjust=-0.25) + labs(x = "Children") + theme(axis.text = element_text(size = 14))
```

The instrument asked about the number of children in different phases but it will only be considered the presence/absence of children.


## Considered states

- 1 = Single + no children
- 2 = Single + children
- 3 = Changing relationships + no children
- 4 = Changing rel. + children
- 5 = Relationship + living apart + no children
- 6 = Relationship + living together + no children 
- 7 = Relationship + living apart + children
- 8 = Relationship + living together + children
- 9 = Married + no children
- 10 = Married + children

```{r, out.width = "280px"}
knitr::include_graphics("../Output/sequence_example2.png")
```

## Distribution of states

```{r final-status, fig.align = "center", out.width = "300px"}
plot5 <- ggplot(data = rh_data, aes(Status_char))
plot5 + geom_bar() + geom_bar() + geom_text(stat = "count", aes(label = ..count..), vjust=-0.25) + scale_x_discrete(guide = guide_axis(n.dodge=2)) + theme(axis.text = element_text(size = 12))
```


## Optimal Matching (OM)

- Technique used in social sciences for the comparison of sequences of categorical states indexed by time.
- Applications on life course and career path analysis. 
- Uses the Needleman-Wunsch algorithm, that was developed to compare biological sequences.
- The Needleman-Wunsch algorithm is an application of dynamic programming, an iterative method that simplifies an optimization problem by breaking it into a recursion of smaller problems.
- Numerical values are assigned to each of this operations and are defined in a **cost matrix**. 
- As a result, pairwise distances between the sequences can be obtained to apply a clustering method.


## Example (i)

Analyzing Sequence Data: Optimal Matching in Management Research (T. Biemann and D. K. Datta)

- Goal: study career paths of deans at US business schools.
- Data source: 149 CVs of deans including public and private business schools.
- Coded into yearly data with the states: administration (A), corporation (C), faculty (F), government (G).

```{r, out.width = "300px", fig.align = "center"}
knitr::include_graphics("../Output/OMA_example0.png")
```

## Example (ii)

Cost matrix:

```{r, out.width = "300px", fig.align = "center"}
knitr::include_graphics("../Output/OMA_example1.png")
```


## Example (iii)

Distance/dissimilarities matrix for five deans:

```{r, out.width = "300px", fig.align = "center"}
knitr::include_graphics("../Output/OMA_example2.png")
```


## Example (iv)

Two of the five resulting clusters:

```{r, out.width = "300px", fig.align = "center"}
knitr::include_graphics("../Output/OMA_example3.png")
```


## Cost matrix (i)

Using the `R` package `TraMineR` the cost matrix is calculated with transition rates between states.

Given a set of $k$ states, say, $S = \{s_1, \dots, s_k\}$, the substitution cost between states $s_i$ and $s_j$, $1 \leq i, j \leq k$, is calculated as:

$$ C(s_i, s_j) = c - P(s_i|s_j) - P(s_j|s_i)  $$

where $P(s_i|s_j)$ is the probability of transition from state $s_i$ in time $t$ to $s_j$ in time $t+1$ and $c$ is a constant (set by default to $c = 2$ so that $0 \leq C(s_i, s_j) \leq 2$)¸.

## Cost matrix (ii)

```{r cost-matrix, echo=FALSE, message=FALSE}
test <- seqformat(rh_data, from = "SPELL", to = "STS",
                  id = "Id", begin = "Start_age", end = "End_age", 
                  status = "Status", covar = "Age", process = FALSE)

alphabet <- as.character(1:10)

my_seq <- seqdef(test, alphabet = alphabet)

cost_matrix_1 <- seqsubm(my_seq, method = "TRATE", with.missing = TRUE)
```

```{r, out.width = "300px", fig.align = "center"}
knitr::include_graphics("../Output/cost_matrix.png")
```


## Distance matrix

- Given $x, y \in X$ two sequences of interest. There different mappings from $T: X \to X$ such that $T(x) = y$. 
- $T$ is composed of elements (operations) that can be insertion, deletion or substitution.
- There is a cost associated with each operation: The substitution cost are given by the cost matrix and insertion/deletion costs are set in a way that reduces/increases the importance of time shifts (low/high).
- The distance between $x$ and $y$ is given by the lower cost mapping.

```{r, echo=FALSE, message=FALSE}
my_dist <- seqdist(my_seq, method = "OM", sm = cost_matrix_1, with.missing = TRUE)
```


## Clustering (i)

- Hierarchical method: Agglomerative Nesting (AGNES).
- At the beginning each individual is a cluster and, at every step, the closest clusters are merged together.
- Distance between two clusters is the average of the distances between the points in one cluster and the points in the other cluster.

```{r, echo=FALSE, message=FALSE}
clusterward <- agnes(my_dist, diss = TRUE, method = "ward")
```


## Clustering (ii)

Dendrogram:

```{r, out.width="300px", fig.align="center"}
plot(clusterward, which.plots = 2, main = "Dendrogram")
abline(h = 153, col = "red")
```


## Clustering (iii)

```{r, echo=FALSE, message=FALSE, cache=TRUE}
clusterward <- agnes(my_dist, diss = TRUE, method = "ward")

clusters <- cutree(clusterward, k = 5)

clusters_labels <- factor(clusters, labels = paste("Cluster", 1:5))
```

```{r, out.width = "320px", fig.align = "center"}
#knitr::include_graphics("../Output/cluster2.png")
par(mar = c(2, 1.7, 0.75, 0.5))
seqdplot(my_seq, group = clusters_labels, border = NA, 
         ltext = status_labels)
dev.off()
```


## Descriptive statistics of personality scores

```{r, echo=FALSE, message=FALSE}
BFI_data <- read_excel("../Data_original/Adriana_BFI.xlsx")

BFI_data <- BFI_data %>% 
  select(PersCode,
         starts_with("BFI"))

pers_descrip <- BFI_data %>% 
  select(PersCode,
         ends_with("mean")) %>% 
  pivot_longer(cols = ends_with("mean"), 
               names_to = "Personality trait", 
               values_to = "Value") %>% 
  group_by(`Personality trait`) %>% 
  summarise(Min = min(Value, na.rm = TRUE),
            Max = max(Value, na.rm = TRUE),
            Average = mean(Value, na.rm = TRUE),
            `Std. deviation` = sd(Value, na.rm = TRUE)) %>% 
  ungroup()

pers_descrip[, 1] <- c("Agreeablenes", "Conscientiousness",
                       "Extraversion", "Neuroticism", "Openness")

knitr::kable(pers_descrip, digits = 2) %>% 
  kableExtra::kable_styling(font_size = 8)
```


## Average personality scores by cluster

```{r, echo=FALSE, message=FALSE}
all_data <- tibble(Id = colnames(my_dist), Cluster = clusters_labels) %>% 
  left_join(BFI_data, by = c("Id" = "PersCode")) %>% 
  select(Id, Cluster, ends_with("mean"))

by_cluster <- all_data %>% 
  group_by(Cluster) %>% 
  summarise(Extraversion = mean(BFI_extraversion_mean, na.rm = TRUE),
            Agreeableness = mean(BFI_agreeableness_mean, 
                                         na.rm = TRUE),
            Conscientiousness = mean(BFI_conscientiousness_mean,
                                             na.rm = TRUE),
            Neuroticism = mean(BFI_neuroticism_mean, na.rm = TRUE),
            Openness = mean(BFI_openness_mean, na.rm = TRUE)) %>% 
  ungroup()

knitr::kable(by_cluster, digits = 2) %>% 
  kableExtra::kable_styling(font_size = 7)
```

Subjective description of the clusters:

- Cluster 1: Married with children then divorced/widowed
- Cluster 2: Sequences with more changes (unstable)
- Cluster 3: Younger, not married with children
- Cluster 4: Not married w/o children
- Cluster 5: Married w/o children

## k-Nearest Neighbors (kNN) algorithm

- It's a non-parametric method.
- Choose the $k$ nearest samples to an individual (distance matrix).
- Calculate the average of the variable of interest with the $k$ samples $\rightarrow$ prediction.
- Use a measure such as $MSE$ to select the optimal $k$.

$$ MSE = \frac{1}{n} \sum_{i=1}^n (Y_i - \hat{Y}_i)^2, $$

where $n$ is the number of data points considered, $Y_i$ is the observed value and $\hat{Y}_i$ is the predicted value.

## k-Nearest Neighbors

```{r, echo=FALSE, message=FALSE, cache=TRUE}
set.seed(123)
n <- dim(all_data)[1]
size <- round(n*0.3)

test_set <- sample.int(n, size)
train_set <- 1:n
train_set <- train_set[-test_set]

test_names <- colnames(my_dist)[test_set]
train_names <- colnames(my_dist)[train_set]

find_neighbors <- function(i, matrix, k){
  data <- sort(matrix[i, ])[-1][1:k]
  return(names(data))
}

preditc_scores <- function(data, neighbors){
  predictions <- data %>% 
    filter(Id %in% neighbors) %>% 
    summarise(Extraversion = mean(BFI_extraversion_mean, na.rm = TRUE),
              Agreeableness = mean(BFI_agreeableness_mean, na.rm = TRUE),
              Conscientiousness = mean(BFI_conscientiousness_mean, na.rm = TRUE),
              Neuroticism = mean(BFI_neuroticism_mean, na.rm = TRUE),
              Openness = mean(BFI_openness_mean, na.rm = TRUE)) %>% 
    as.vector() %>% 
    unlist()
  return(predictions)
}

K <- 30
results_train <- list()

for(k in 1:K){
all_neighbors_train <- list()

for(i in seq_along(train_set)){
  all_neighbors_train[[i]] <- find_neighbors(train_set[i], matrix = my_dist, k = k)
}

names(all_neighbors_train) <- train_names

all_predictions_train <- list()

for(i in seq_along(train_set)){
  all_predictions_train[[i]] <- preditc_scores(all_data, neighbors = all_neighbors_train[[i]])
}

names(all_predictions_train) <- train_names

predictions_train_df <- do.call(rbind.data.frame, all_predictions_train)

colnames(predictions_train_df) <- names(all_predictions_train[[1]])

predictions_train_df[, "Id"] <- train_names

sq_error_train <- predictions_train_df %>% 
  left_join(all_data, by = "Id") %>% 
  mutate(sq_diff_Extraversion = (Extraversion - BFI_extraversion_mean)^2,
         sq_diff_Agreeableness = (Agreeableness - BFI_agreeableness_mean)^2,
         sq_diff_Conscientiousness = (Conscientiousness - BFI_conscientiousness_mean)^2,
         sq_diff_Neuroticism = (Neuroticism - BFI_neuroticism_mean)^2,
         sq_diff_Openness = (Openness - BFI_openness_mean)^2) %>% 
  select(Id, Cluster, starts_with("sq_diff")) %>% 
  pivot_longer(starts_with("sq_diff"), names_to = "Score", values_to = "Value") %>% 
  group_by(Score) %>% 
  summarise(MSQ = mean(Value, na.rm = TRUE)) %>% 
  ungroup()

colnames(sq_error_train)[2] <- paste0("MSQ_", k)

sq_error_train[, 1] <- c("Agreeablenes", "Conscientiousness",
                        "Extraversion", "Neuroticism", "Openness")

results_train[[k]] <- sq_error_train
}

train_MSQ <- results_train %>% 
  purrr::reduce(left_join, by = "Score") %>% 
  pivot_longer(starts_with("MSQ_"), names_prefix = "MSQ_", names_to = "k", 
               values_to = "MSE") %>% 
  mutate(k = as.numeric(k))
```

```{r, echo=FALSE, message=FALSE, out.width = "300px", fig.align = "center"}
ggplot(data = train_MSQ, aes(x = k, y = MSE, col = Score)) +
  geom_line()
```


## What's next?

- Use the kNN predictions to tune the parameters used in the specification of the cost matrix (e.g. indel cost, transition cost calculation)
- Try other prediction methods (e.g. distance-based linear models)


## References

- Sequence Analysis: New Methods for Old Ideas - A. Abbott (1995)
- Optimal Matching Analysis: A Methodological Note on Studying Career Mobility - T. W. Chan (1995)
- Analyzing Sequence Data: Optimal Matching in
Management Research - T. Biemann & D. K. Datta (2013)
- Analyzing and Visualizing State Sequences in R
with TraMineR - A. Gabadinho, G. Ritschard, N. S. Müller, M. Studer (2011)